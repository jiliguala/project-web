'use strict';
const through = require('through2');
const normalize = require('normalize-path');
const path = require('path');
const fs = require('fs-extra');
/**
 * 创建GulpMap
 */
class GulpMap {
    constructor(opts) {
        this.opts = Object.assign({
            uri: '', // 构建地址前缀
            namespace: '' // 构建命名空间
        }, opts);
        this.map = {};
    }
    /**
     * 存储路径信息
     * @param  {Object}   opts 存储选项,如果replace和to同时存在,则会替换对应后缀
     * @return {Function}      gulp处理对象
     */
    savePath(opts) {
        const saveOpts = Object.assign({
            replace: '',
            to: '',
            hash: false
        }, opts);
        const _this = this;
        if((saveOpts.replace || saveOpts.to) && !(saveOpts.replace && saveOpts.to)) {
            throw new Error('You must both set "replace" & "to" by calling "savePath"');
        }
        return through.obj(function(file, encoding, callback) {
            // 如果是文件夹则跳过
            if(!file.isDirectory()) {
                const filepath = normalize(file.relative).replace(/^([^\/])/, '/$1'); //替换非/开头的为/
                let nameKey = (_this.opts.namespace ? (_this.opts.namespace + ':') : '') + filepath;
                if(saveOpts.hash) {
                    if(!file.origPath && !file.revPathOriginal) return callback(null, file);
                    if(file.origPath) {
                        nameKey = (_this.opts.namespace ? (_this.opts.namespace + ':') : '') + normalize(file.origPath).replace(/^([^\/])/, '/$1');
                    }
                    if(file.revPathOriginal) {
                        nameKey = nameKey.replace(/[^\/]+$/, path.parse(file.revPathOriginal).base);
                    }
                }
                const ext = path.parse(filepath).ext;
                const type = ext.replace('.', '');
                if(saveOpts.replace && saveOpts.to) {
                    _this.map[nameKey] = {
                        'source': nameKey.replace(new RegExp('.' + saveOpts.replace + '$'), '.' + saveOpts.to),
                        'type': type
                    };
                }
                else {
                    _this.map[nameKey] = {
                        'uri': _this.opts.uri + filepath,
                        'type': type
                    };
                }
            }
            callback(null, file);
        });
    }

    getMap() {
        return this.map;
    }

    /**
     * 构建map地址
     * @param  {String} buildDir 设置构建地址
     */
    buildMap(buildDir, options) {
        const opts = Object.assign({
            name: 'map.json'
        }, options);
        if(!buildDir) throw new Error('You must set "buildDir" & "to" by calling "buildMap"');
        const mapDir = path.join(process.cwd(), buildDir);
        fs.ensureDirSync(mapDir);
        fs.writeJsonSync(path.join(mapDir, opts.name), this.map);
    }
}

module.exports = GulpMap;